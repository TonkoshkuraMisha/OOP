"""
Под инкапсуляцией в объектно-ориентированном программировании понимается упаковка
данных и методов для их обработки вместе, т. е. в классе. В Python инкапсуляция реализуется
как на уровне классов, так и объектов.

В Python подобной инкапсуляции нет, хотя существует способ ее имитировать. Перед тем как
выяснять, как это делается, надо понять, зачем вообще что-то скрывать.
"""


# class B:
#     count = 0
#
#     def __init__(self):
#         B.count += 1
#
#     def __del__(self):
#         B.count -= 1
#
#
# a = B()
# b = B()
# print(B.count)  # выведет 2
# del a
# print(B.count)  # выведет 1

"""
Для имитации сокрытия атрибутов в Python используется соглашение (соглашение – это не 
синтаксическое правило языка, при желании его можно нарушить), согласно которому, если 
поле или метод имеют два знака подчеркивания впереди имени, но не сзади, то этот атрибут 
предусмотрен исключительно для внутреннего пользования.
"""


class B:
    __count = 0

    def __init__(self):
        B.__count += 1

    def __del__(self):
        B.__count -= 1


a = B()
# print(B.__count)
print(B._B__count)

"""
Попытка выполнить этот код приведет к выбросу исключения.
То есть атрибут __count за пределами класса становится невидимым, хотя внутри класса он 
вполне себе видимый. Понятно, если мы не можем даже получить значение поля за пределами 
класса, то присвоить ему значение – тем более.

На самом деле сокрытие в Python не настоящее и доступ к счетчику мы получить все же можем. 
Но для этого надо написать B._B__count:
Таково соглашение. Если в классе есть атрибут с двумя первыми подчеркиваниями, то для 
доступа извне к имени атрибута добавляется имя класса с одним впереди стоящим 
подчеркиванием. В результате атрибут как он есть (в данном случае __count) оказывается 
замаскированным. Вне класса такого атрибута просто не существует. Для программиста же 
наличие двух подчеркиваний перед атрибутом должно сигнализировать, что трогать его вне 
класса не стоит вообще, даже через _B__count, разве что при крайней необходимости. 
"""
