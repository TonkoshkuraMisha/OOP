"""
Примером итерируемого объекта является список. Примером итератора – файловый объект.
Список включает в себя все свои элементы, а файловый объект по-очереди "вынимает" из себя
элементы и "забывает" то, что уже вынул. Также не ведает, что в нем содержится еще, так как
это "еще" может вычисляться при каждом обращении или поступать извне. Например,
файловый объект не знает сколько еще текста в связанном с ним файле.

У всех итераторов, но не итерируемых объектов, есть метод __next__(). Именно его код
обеспечивает выдачу очередного элемента. Каков этот код, зависит от конкретного класса.
Когда итератор выдал все свои значения, то очередной вызов __next__() должен возбуждать
исключение StopIteration.
На самом деле цикл for ожидает, что у объекта есть не только метод __next__(), но и __iter__().
Задача метода __iter__() – "превращать" итерируемый объект в итератор. Если в цикл for
передается уже итератор, то метод __iter__() этого объекта должен возвращать сам объект.
Как видно, объект класса list_iterator исчерпывается как нормальный итератор. Список s при
этом никак не меняется. Отсюда понятно, почему после обхода циклом for итерируемые
объекты остаются в прежнем составе. От них создается "копия"-итератор, а с ними самими цикл
for не работает.

"""


class Letters:
    def __init__(self, string):
        self.letters = []
        for i in string:
            self.letters.append(f'-{i}-')

    def __iter__(self):
        return LettersIterator(self.letters[:])


class LettersIterator:
    def __init__(self, letters):
        self.letters = letters

    def __iter__(self):
        return self

    def __next__(self):
        if self.letters == []:
            raise StopIteration
        item = self.letters[0]
        del self.letters[0]
        return item


kit = Letters('aeoui')
print(kit.letters)
for i in kit:
    print(i)
print(kit.letters)
